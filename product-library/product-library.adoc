= API documentation for iZettle Product Library


[[_overview]]
== Overview
A product library is a representation of all the items that can be displayed, put in a shopping cart and sold to a customer. Items may be either producs or discounts.

A product is a syntethic construct, wrapping one or more variants (which is the actual item being sold). Variants expresses different variations of properties such as for example price, size or color.

A discount will reduce the total amount charged in a shopping cart. It can be used per item line, or on the whole cart. It may reduce the affected amount by a percentage, or by a fixed amount.

Modifiers is defined as a separate entity, and can be referenced from a product. This will enable the product to have different "modifiers" that can alter it's final price. For example different dressings (modifiers) added on top of a salad (product)

Together, the above types of entities makes up a complete library. The library can be fetched as a whole through the library endpoint, where each consecutive change applied to the library is available. Once the full library is retrieved, only later events needs to be fetched to keep the client up to date with the server.

All path patterns "/organizations/{organizationUuid}/" can be replaced by "/organizations/self/" for convenience as all endpoints are for authorized users.


=== Version information
[%hardbreaks]
_Version_ : v1.0


=== Contact information
[%hardbreaks]
_Contact_ : iZettle Storefront team
_Contact Email_ : storefront@izettle.com


=== URI scheme
[%hardbreaks]
_BasePath_ : /
_Schemes_ : HTTPS, HTTP


=== Tags

* discounts
* export
* library
* modifiersets
* products


=== Consumes

* `application/json`


=== Produces

* `application/json`




[[_paths]]
== Paths

[[_creatediscount]]
=== Creates a single discount entity
....
POST /organizations/{organizationUuid}/discounts
....


==== Description
Crates a single discount entity. The location of the newly created discount will be available in the successful response as a Location header


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|*Body*|*body* +
_required_|The new discount to create|<<_discountrequest,DiscountRequest>>
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*default*|successful operation|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* discounts


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|WRITE:PRODUCT
|===


[[_getalldiscounts]]
=== Retrieves all discount
....
GET /organizations/{organizationUuid}/discounts
....


==== Description
Get all discount entities that the authorized user has access to.


==== Parameters

[options="header", cols=".^2,.^3,.^4"]
|===
|Type|Name|Schema
|*Path*|*organizationUuid* +
_required_|string(uuid)
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*200*|successful operation|< <<_discount,discount>> > array
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* discounts


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|READ:PRODUCT
|===


[[_getdiscount]]
=== Retrieves a single discount entity
....
GET /organizations/{organizationUuid}/discounts/{discountUuid}
....


==== Description
Get the full discount with the provided UUID. The method supports conditional GET through providing a If-None-Match header. If the conditional prerequisite is fullfilled, the full discount is returned: otherwise a 304 not modified will be returned with an empty body.


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*discountUuid* +
_required_|Discount Identifier as an UUID|string(uuid)
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*200*|successful operation +
*Headers* :  +
`ETag` (string) : The ETag of the returned version of the discount.|<<_discount,discount>>
|*304*|Not Modified|No Content
|*404*|Not found|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* discounts


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|READ:PRODUCT
|===


[[_updatediscount]]
=== Updates a single discount entity
....
PUT /organizations/{organizationUuid}/discounts/{discountUuid}
....


==== Description
Updates a discount entity using JSON merge patch (https://tools.ietf.org/html/rfc7386). This means that only included fields will be changed: null values removes the field on the target entity, and other values updates the field.

Conditional updates are supported through the If-Match header. If the conditional prerequisite is fullfilled, the discount is updated: otherwise a 412 precondition failed will be returned with an empty body.


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*discountUuid* +
_required_|Discount Identifier as an UUID|string(uuid)
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|*Body*|*body* +
_required_|The new version of the discount to update, partials of the object can be provided as per JSON merge patch|<<_discountrequest,DiscountRequest>>
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*404*|Not found|No Content
|*412*|Precondition failed: ETag did not match the expected value|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* discounts


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|WRITE:PRODUCT
|===


[[_deletediscount]]
=== Deletes a single discount entity
....
DELETE /organizations/{organizationUuid}/discounts/{discountUuid}
....


==== Description
Deletes a discount entity


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*discountUuid* +
_required_|Discount Identifier as an UUID|string(uuid)
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*404*|discount not found|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* discounts


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|WRITE:PRODUCT
|===


[[_exportallproducts]]
=== GET /organizations/{organizationUuid}/export/products/{type}

==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|*Path*|*type* +
_required_||enum (CSV, XLS)
|*Query*|*productUUIDs* +
_optional_|Optional list of product UUIDs to export|< string(uuid) > array(multi)
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*default*|successful operation|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `text/comma-separated-values`
* `application/excel`


==== Tags

* export


[[_exporttemplate]]
=== GET /organizations/{organizationUuid}/export/products/{type}/template

==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|*Path*|*type* +
_required_||enum (CSV, XLS)
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*default*|successful operation|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `text/comma-separated-values`
* `application/excel`


==== Tags

* export


[[_getlibrarysnapshot]]
=== Retrieves the entire library
....
GET /organizations/{organizationUuid}/library
....


==== Description
Will return the entire library for the authenticated user. If size of the library exceeds server preferences (normally 500) or the value of the optional limit parameter, the result will be paginated. Pagination is indicated by returning a Link header, indicating next URI to fetch.

The resulting header value will look something like: 'https://products.izettle.com/organizations/self/library?limit=X&offset=Y; rel="next"' where limit is number of items in response, and offset is current position in pagination. The rel-part in the header is the links relation to the data previously recieved. The idea is as long as this header is present there are still items remaining to be fetched. When either the header is not present or it's value doesn't contain any "next" value, all items have been sent to the client.

Note: The client should NOT try to extract query parameters from the IRI, but rather use it as-is for the next request. Also, clients should be perpared that one Link header might contain multiple other IRIs that are not "next" (there will never be more than one "next" though).

See more at:
 IETF: https://tools.ietf.org/html/rfc5988
GitHub: https://developer.github.com/guides/traversing-with-pagination/
If eventLogUuid is provided, the response will only include events affecting the library since that event. Such responses are normally quite small and would be a prefered method for most fat clients after retrieving the initial full library


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|*Query*|*eventLogUuid* +
_optional_|The uuid of the earliest eventlog already known to the client|string(uuid)
|*Query*|*limit* +
_optional_|The max number of items returned per request|integer(int32)
|*Query*|*offset* +
_optional_|The offset within the current snapshot for the current page|string(uuid)
|*Query*|*snapshotUuid* +
_optional_|The uuid of the snapshot currently paging through|string(uuid)
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*200*|successful operation +
*Headers* :  +
`Link` (string) : If the response is paginated, this header will contain the URI for the next page. See more at: https://tools.ietf.org/html/rfc5988.|<<_library,library>>
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* library


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|READ:PRODUCT
|===


[[_deletemodifier]]
=== Deletes a single modifier entity belonging to the modifier set. Since it's a precondition that all modifier sets have at least one modifier it is not possible to delete the last remaining modifier on the specified modifier set.
....
DELETE /organizations/{organizationUuid}/modifierset/{modifiersetUuid}/modifiers/{modifierUuid}
....


==== Description
Deletes the modifier entity


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*modifierSetUuids* +
_required_|Modifier Set Identifier as an UUID|string(uuid)
|*Path*|*modifierUuid* +
_required_|Modifier Identifier as an UUID|string(uuid)
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*400*|Unable to delete last remaning modifier|No Content
|*404*|Modifier set not found|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* modifiersets


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|WRITE:PRODUCT
|===


[[_createmodifierset]]
=== Creates a single product entity
....
POST /organizations/{organizationUuid}/modifiersets
....


==== Description
Crates a single modifier set entity. The location of the newly created modifier set will be available in the successful response as a Location header


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|*Body*|*body* +
_required_|The new modifier set to create|<<_modifiersetcreaterequest,ModifierSetCreateRequest>>
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*default*|successful operation|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* modifiersets


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|WRITE:PRODUCT
|===


[[_getallmodifiersets]]
=== Retrieves all modifier sets
....
GET /organizations/{organizationUuid}/modifiersets
....


==== Description
Get all modifier set entities that the authorized user has access to.


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*200*|successful operation|< <<_modifierset,modifierSet>> > array
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* modifiersets


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|READ:PRODUCT
|===


[[_getmodifierset]]
=== Retrieves a single product entity
....
GET /organizations/{organizationUuid}/modifiersets/{modifierSetUuid}
....


==== Description
Get the full modifier set with the provided UUID. The method supports conditional GET through providing a If-None-Match header. If the conditional prerequisite is fullfilled, the full modifier set is returned: otherwise a 304 not modified will be returned with an empty body.


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*modifierSetUuid* +
_required_|Modifier Set Identifier as an UUID|string(uuid)
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*200*|successful operation +
*Headers* :  +
`ETag` (string) : The ETag of the returned version of the modifier set.|<<_modifierset,modifierSet>>
|*304*|Not Modified|No Content
|*404*|Not found|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* modifiersets


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|READ:PRODUCT
|===


[[_updatemodifierset]]
=== Updates a single modifier set entity
....
PUT /organizations/{organizationUuid}/modifiersets/{modifierSetUuid}
....


==== Description
Updates a modifier set entity using JSON merge patch (https://tools.ietf.org/html/rfc7386). This means that only included fields will be changed: null values removes the field on the target entity, and other values updates the field.

To be able to do this consistently, no updates can be done on modifiers at this level: only their mutual order. For adding, deleting or updating modifiers themselves, see /organizations/{organizationUuid}/modifiersets/{modifierSetUuid}/modifiers/{modifierUuid}.

Conditional updates are supported through the If-Match header. If the conditional prerequisite is fullfilled, the modifier set is updated: otherwise a 412 precondition failed will be returned with an empty body.


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*modifierSetUuid* +
_required_|Modifier Set Identifier as an UUID|string(uuid)
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|*Body*|*body* +
_required_|The new version of the modifier set to update, partials of the object can be provided as per JSON merge patch|<<_modifiersetupdaterequest,ModifierSetUpdateRequest>>
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*404*|Not found|No Content
|*412*|Precondition failed: ETag did not match the expected value|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* modifiersets


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|WRITE:PRODUCT
|===


[[_deletemodifierset]]
=== Deletes a single modifier set entity
....
DELETE /organizations/{organizationUuid}/modifiersets/{modifierSetUuid}
....


==== Description
Deletes a modifier set entity


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*modifierSetUuid* +
_required_|Modifier Set Identifier as an UUID|string(uuid)
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*404*|modifier set not found|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* modifiersets


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|WRITE:PRODUCT
|===


[[_createmodifier]]
=== Create a single modifier entity
....
POST /organizations/{organizationUuid}/modifiersets/{modifierSetUuid}/modifiers
....


==== Description
Creates a modifier entity. The location of updated modifier set with the newly created modifier will be available in the successful response as a Location header


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*modifierSetUuid* +
_required_|Modifier Set Identifier as an UUID|string(uuid)
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|*Body*|*body* +
_required_|The new modifier to create|<<_modifier,modifier>>
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*default*|successful operation|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* modifiersets


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|WRITE:PRODUCT
|===


[[_updatemodifier]]
=== Updates a single modifier entity
....
PUT /organizations/{organizationUuid}/modifiersets/{modifierSetUuid}/modifiers/{modifierUuid}
....


==== Description
Updates a modifier entity using JSON merge patch (https://tools.ietf.org/html/rfc7386). This means that only included fields will be changed: null values removes the field on the target entity, and other values updates the field.

Conditional updates are supported through the If-Match header. If the conditional prerequisite is fullfilled, the modifier is updated: otherwise a 412 precondition failed will be returned with an empty body.


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*modifierSetUuid* +
_required_|Modifier Set Identifier as an UUID|string(uuid)
|*Path*|*modifierUuid* +
_required_|Modifier Identifier as an UUID|string(uuid)
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|*Body*|*body* +
_required_|The new version of the modifier to update, partials of the object can be provided as per JSON merge patch|<<_modifier,modifier>>
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*404*|Not found|No Content
|*412*|Precondition failed: ETag did not match the expected value|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* modifiersets


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|WRITE:PRODUCT
|===


[[_createproduct]]
=== Creates a single product entity
....
POST /organizations/{organizationUuid}/products
....


==== Description
Creates a single product entity. The location of the newly created product will be available in the successful response as a Location header


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|*Body*|*body* +
_required_|The new product to create|<<_productcreaterequest,ProductCreateRequest>>
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*default*|successful operation|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* products


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|WRITE:PRODUCT
|===


[[_getallproducts]]
=== Retrieves all products
....
GET /organizations/{organizationUuid}/products
....


==== Description
Get all product entities that the authorized user has access to. The response might be fairly large, so clients with limited capacity might want to use the library endpoint instead


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*200*|successful operation|< <<_product,product>> > array
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* products


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|READ:PRODUCT
|===


[[_deleteproducts]]
=== Bulk delete product entities
....
DELETE /organizations/{organizationUuid}/products
....


==== Description
Build delete product entities.


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|*Query*|*uuid* +
_required_|List of products to delete|< string(uuid) > array(multi)
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*default*|successful operation|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* products


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|WRITE:PRODUCT
|===


[[_getproduct]]
=== Retrieves a single product entity
....
GET /organizations/{organizationUuid}/products/{productUuid}
....


==== Description
Get the full product with the provided UUID. The method supports conditional GET through providing a If-None-Match header. If the conditional prerequisite is fullfilled, the full product is returned: otherwise a 304 not modified will be returned with an empty body.


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|*Path*|*productUuid* +
_required_|Product Identifier as an UUID|string(uuid)
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*200*|successful operation +
*Headers* :  +
`ETag` (string) : The ETag of the returned version of the product.|<<_product,product>>
|*304*|Not Modified|No Content
|*404*|Not found|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* products


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|READ:PRODUCT
|===


[[_updateproduct]]
=== Updates a single product entity
....
PUT /organizations/{organizationUuid}/products/{productUuid}
....


==== Description
Updates a product entity using JSON merge patch (https://tools.ietf.org/html/rfc7386). This means that only included fields will be changed: null values removes the field on the target entity, and other values updates the field.

To be able to do this consistently, no updates can be done on variants at this level: only their mutual order. For adding, deleting or updating variants themselves, see products/{productUuid}/variants/{variantUuid}.

Conditional updates are supported through the If-Match header. If the conditional prerequisite is fullfilled, the product is updated: otherwise a 412 precondition failed will be returned with an empty body.


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|*Path*|*productUuid* +
_required_|Product Identifier as an UUID|string(uuid)
|*Body*|*body* +
_required_|The new version of the product to update, partials of the object can be provided as per JSON merge patch|<<_productupdaterequest,ProductUpdateRequest>>
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*404*|Not found|No Content
|*412*|Precondition failed: ETag did not match the expected value|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* products


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|WRITE:PRODUCT
|===


[[_deleteproduct]]
=== Deletes a single product entity
....
DELETE /organizations/{organizationUuid}/products/{productUuid}
....


==== Description
Deletes a product entity


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|*Path*|*productUuid* +
_required_|Product Identifier as an UUID|string(uuid)
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*404*|Product not found|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* products


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|WRITE:PRODUCT
|===


[[_createvariant]]
=== Creates a single variant entity
....
POST /organizations/{organizationUuid}/products/{productUuid}/variants
....


==== Description
Creates a single variant entity. The location of updated product with the newly created variant will be available in the successful response as a Location header


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|*Path*|*productUuid* +
_required_|Product Identifier as an UUID|string(uuid)
|*Body*|*body* +
_required_|The new variant to create|<<_variant,variant>>
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*default*|successful operation|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* products


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|WRITE:PRODUCT
|===


[[_updatevariant]]
=== Updates a single variant entity
....
PUT /organizations/{organizationUuid}/products/{productUuid}/variants/{variantUuid}
....


==== Description
Updates a variant entity using JSON merge patch (https://tools.ietf.org/html/rfc7386). This means that only included fields will be changed: null values removes the field on the target entity, and other values updates the field.

Conditional updates are supported through the If-Match header. If the conditional prerequisite is fullfilled, the variant is updated: otherwise a 412 precondition failed will be returned with an empty body.


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|*Path*|*productUuid* +
_required_|Product Identifier as an UUID|string(uuid)
|*Path*|*variantUuid* +
_required_|Variant Identifier as an UUID|string(uuid)
|*Body*|*body* +
_required_|The new version of the variant to update, partials of the object can be provided as per JSON merge patch|<<_variant,variant>>
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*404*|Not found|No Content
|*412*|Precondition failed: ETag did not match the expected value|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* products


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|WRITE:PRODUCT
|===


[[_deletevariant]]
=== Deletes the variant entity
....
DELETE /organizations/{organizationUuid}/products/{productUuid}/variants/{variantUuid}
....


==== Description
Deletes a single variant entity belonging to the product. Since it's a precondition that all products have at least one variant it is not possible to delete the last remaining variant on specified product.


==== Parameters

[options="header", cols=".^2,.^3,.^9,.^4"]
|===
|Type|Name|Description|Schema
|*Path*|*organizationUuid* +
_required_|Organization Identifier as an UUID|string(uuid)
|*Path*|*productUuid* +
_required_|Product Identifier as an UUID|string(uuid)
|*Path*|*variantUuid* +
_required_|Variant Identifier as an UUID|string(uuid)
|===


==== Responses

[options="header", cols=".^2,.^14,.^4"]
|===
|HTTP Code|Description|Schema
|*400*|Unable to delete last remaning variant|No Content
|*404*|Product not found|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* products


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*oauth2*|*<<_oauth2,oauth2>>*|WRITE:PRODUCT
|===




[[_definitions]]
== Definitions

[[_discountrequest]]
=== DiscountRequest

[options="header", cols=".^3,.^4"]
|===
|Name|Schema
|*amount* +
_optional_|<<_price,Price>>
|*description* +
_optional_ +
_read-only_|string
|*externalReference* +
_optional_ +
_read-only_|string
|*imageLookupKeys* +
_optional_|< string > array
|*name* +
_optional_ +
_read-only_|string
|*percentage* +
_optional_ +
_read-only_|string
|*uuid* +
_required_ +
_read-only_|string(uuid)
|===


[[_modifiersetcreaterequest]]
=== ModifierSetCreateRequest

[options="header", cols=".^3,.^11,.^4"]
|===
|Name|Description|Schema
|*modifiers* +
_required_||< <<_modifier,modifier>> > array
|*name* +
_required_ +
_read-only_|*Length* : `1 - 2147483647`|string
|*uuid* +
_required_ +
_read-only_||string(uuid)
|===


[[_modifiersetupdaterequest]]
=== ModifierSetUpdateRequest

[options="header", cols=".^3,.^11,.^4"]
|===
|Name|Description|Schema
|*modifierUuids* +
_required_||< string(uuid) > array
|*name* +
_required_ +
_read-only_|*Length* : `1 - 2147483647`|string
|*uuid* +
_required_ +
_read-only_||string(uuid)
|===


[[_price]]
=== Price

[options="header", cols=".^3,.^11,.^4"]
|===
|Name|Description|Schema
|*amount* +
_required_ +
_read-only_|*Minimum value* : `0`|integer(int64)
|*currencyId* +
_required_ +
_read-only_||enum (AED, AFA, AFN, ALL, AMD, ANG, AOA, ARS, AUD, AWG, AZM, AZN, BAM, BBD, BDT, BGN, BHD, BIF, BMD, BND, BOB, BRL, BSD, BTN, BWP, BYR, BZD, CAD, CDF, CHF, CLP, CNY, COP, CRC, CSD, CUC, CUP, CVE, CYP, CZK, DJF, DKK, DOP, DZD, EEK, EGP, ERN, ETB, EUR, FJD, FKP, GBP, GEL, GGP, GHC, GHS, GIP, GMD, GNF, GTQ, GYD, HKD, HNL, HRK, HTG, HUF, IDR, ILS, IMP, INR, IQD, IRR, ISK, JEP, JMD, JOD, JPY, KES, KGS, KHR, KMF, KPW, KRW, KWD, KYD, KZT, LAK, LBP, LKR, LRD, LSL, LTL, LVL, LYD, MAD, MDL, MGA, MKD, MMK, MNT, MOP, MRO, MTL, MUR, MVR, MWK, MXN, MYR, MZM, MZN, NAD, NGN, NIO, NOK, NPR, NZD, OMR, PAB, PEN, PGK, PHP, PKR, PLN, PYG, QAR, RON, RSD, RUB, RWF, SAR, SBD, SCR, SDD, SDG, SEK, SGD, SHP, SIT, SKK, SLL, SOS, SPL, SRD, SSP, STD, SVC, SYP, SZL, THB, TJS, TMM, TMT, TND, TOP, TRL, TRY, TTD, TVD, TWD, TZS, UAH, UGX, USD, UYU, UZS, VEB, VEF, VND, VUV, WST, XAF, XAG, XAU, XCD, XDR, XOF, XPD, XPF, XPT, YER, ZAR, ZMK, ZMW, ZWD, ZWL)
|===


[[_productcreaterequest]]
=== ProductCreateRequest

[options="header", cols=".^3,.^11,.^4"]
|===
|Name|Description|Schema
|*categories* +
_optional_||< string > array
|*description* +
_optional_ +
_read-only_||string
|*externalReference* +
_optional_ +
_read-only_||string
|*imageLookupKeys* +
_optional_||< string > array
|*modifierSetUuids* +
_optional_ +
_read-only_||string(uuid)
|*name* +
_required_ +
_read-only_|*Length* : `1 - 2147483647`|string
|*uuid* +
_required_ +
_read-only_||string(uuid)
|*variants* +
_required_||< <<_variant,variant>> > array
|===


[[_productupdaterequest]]
=== ProductUpdateRequest

[options="header", cols=".^3,.^4"]
|===
|Name|Schema
|*categories* +
_optional_|< string > array
|*description* +
_optional_ +
_read-only_|string
|*externalReference* +
_optional_ +
_read-only_|string
|*imageLookupKeys* +
_optional_|< string > array
|*modifierSetUuids* +
_optional_|< string(uuid) > array
|*name* +
_required_ +
_read-only_|string
|*uuid* +
_required_ +
_read-only_|string(uuid)
|*variantUuids* +
_required_|< string(uuid) > array
|===


[[_discount]]
=== discount

[options="header", cols=".^3,.^4"]
|===
|Name|Schema
|*amount* +
_optional_|<<_price,Price>>
|*created* +
_required_ +
_read-only_|integer(int64)
|*description* +
_optional_ +
_read-only_|string
|*etag* +
_required_ +
_read-only_|string
|*externalReference* +
_optional_ +
_read-only_|string
|*imageLookupKeys* +
_optional_|< string > array
|*name* +
_required_ +
_read-only_|string
|*percentage* +
_optional_ +
_read-only_|string
|*updated* +
_required_ +
_read-only_|integer(int64)
|*updatedBy* +
_optional_ +
_read-only_|string(uuid)
|*uuid* +
_required_ +
_read-only_|string(uuid)
|===


[[_library]]
=== library

[options="header", cols=".^3,.^4"]
|===
|Name|Schema
|*deletedDiscounts* +
_optional_|< string(uuid) > array
|*deletedModifierSets* +
_optional_|< string(uuid) > array
|*deletedProducts* +
_optional_|< string(uuid) > array
|*discounts* +
_optional_|< <<_discount,discount>> > array
|*fromEventLogUuid* +
_optional_ +
_read-only_|string(uuid)
|*modifierSets* +
_optional_|< <<_modifierset,modifierSet>> > array
|*products* +
_optional_|< <<_product,product>> > array
|*untilEventLogUuid* +
_optional_ +
_read-only_|string(uuid)
|===


[[_modifier]]
=== modifier

[options="header", cols=".^3,.^4"]
|===
|Name|Schema
|*description* +
_optional_ +
_read-only_|string
|*name* +
_required_ +
_read-only_|string
|*price* +
_optional_|<<_price,Price>>
|*uuid* +
_required_ +
_read-only_|string(uuid)
|===


[[_modifierset]]
=== modifierSet

[options="header", cols=".^3,.^4"]
|===
|Name|Schema
|*created* +
_required_ +
_read-only_|integer(int64)
|*etag* +
_required_ +
_read-only_|string
|*modifiers* +
_required_|< <<_modifier,modifier>> > array
|*name* +
_required_ +
_read-only_|string
|*updated* +
_required_ +
_read-only_|integer(int64)
|*updatedBy* +
_optional_ +
_read-only_|string(uuid)
|*uuid* +
_required_ +
_read-only_|string(uuid)
|===


[[_product]]
=== product

[options="header", cols=".^3,.^4"]
|===
|Name|Schema
|*categories* +
_optional_|< string > array
|*created* +
_required_ +
_read-only_|integer(int64)
|*description* +
_optional_ +
_read-only_|string
|*etag* +
_required_ +
_read-only_|string
|*externalReference* +
_optional_ +
_read-only_|string
|*imageLookupKeys* +
_optional_|< string > array
|*modifierSetUuids* +
_optional_|< string(uuid) > array
|*name* +
_required_ +
_read-only_|string
|*updated* +
_required_ +
_read-only_|integer(int64)
|*updatedBy* +
_optional_ +
_read-only_|string(uuid)
|*uuid* +
_required_ +
_read-only_|string(uuid)
|*variants* +
_optional_|< <<_variant,variant>> > array
|===


[[_variant]]
=== variant

[options="header", cols=".^3,.^4"]
|===
|Name|Schema
|*barcode* +
_optional_ +
_read-only_|string
|*costPrice* +
_optional_|<<_price,Price>>
|*defaultQuantity* +
_optional_ +
_read-only_|enum (1)
|*description* +
_optional_ +
_read-only_|string
|*name* +
_optional_ +
_read-only_|string
|*price* +
_optional_|<<_price,Price>>
|*sku* +
_optional_ +
_read-only_|string
|*unitName* +
_optional_ +
_read-only_|string
|*uuid* +
_required_ +
_read-only_|string(uuid)
|*vatPercentage* +
_optional_ +
_read-only_|string
|===




[[_securityscheme]]
== Security

[[_oauth2]]
=== oauth2
[%hardbreaks]
_Type_ : oauth2
_Flow_ : implicit
_Token URL_ : https://oauth.izettle.net


[options="header", cols=".^3,.^17"]
|===
|Name|Description
|READ:PRODUCT|Access to read product library data
|WRITE:PRODUCT|Access to modify product library data
|===



